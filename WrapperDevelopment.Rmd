---
title: "Develop atlantisom wrappers"
author: "Sarah Gaichas and Christine Stawitz"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Too many steps! and too much memory!

We can run atlantisom with many functions to get stock assessment model inputs.

To make life easier, here are some wrapper functions to do the basic things we want.

Basic desired functionality:

1. initialize: locate model output (function to make a config file?), read in basic run parameters and species names, run_truth for all once and save output 
    + User to make up front decision--want all species or just a subset?
    + May want multiple species that need to be split in a later step for models
    + wraps functions 
        + sourcing model config file--add function to make config file?
      + specifies top directory for source files, names key files for use later
      + load_fgs
      + load all other needed files--YOY, catch
      + run_truth
1. get assessment input data: configure survey, run all survey functions, configure fishery, run all fishery functions (how to save output?)
    + Based on decision above, save interim steps for use later
    + Need a switch for single vs multispecies estimation models?
    + Separate index and comp functions in output
    + indices:
      + create survey config file(s), default is a census of all see census_spec.R
        + survey index in biomass or numbers? (uses truth$biomass_ages vs truth$nums)
        + wraps functions create_survey, sample_survey_biomass
      + create fishery config file(s)
    + comps:
      + select age only or age and length
        + age only wraps create_survey using nums with sample_fish to get age comps
        + age and length (with weight at age)
          + create_survey followed by sample_fish, 
          + aggregateDensityData for resn and structn followed by sample_fish
          + inputs all to calc_age2length
      + catch comps wrap create_fishery_subset with sample_fish to get age comps, same as above for lengths
1. write input data for specific model: wrap functions in development for SS3, add functions for other models (ASAP, multispecies models)
    + wrap r4ss functions to read and write dat and ctl files
    + possibly start with set of dummy SS files with package (take from ss3sim?)
      + read in dat file
      + indices wrap SS_write_ts
      + comps wrap reformat_compositions, SS_write_comps, some of the checks for bin matches
      + write full dat file
    + start with dummy ctl file (any from ss3sim?)
      + read in ctl file
      + wrap SS_write_bio using outputs of calc_Z, load_YOY, load_biolprm, load_runprm, etc
1. run specified model--automate for scenarios, save outputs 
1. skill assessment metrics: compare stored Atlantis truth with model output 
    
### atlantisom initialize function

Things to add: checks for output timestep?

```{r ominit}

library(tidyverse)

om_init <- function(config = configfile){
  
  # Where are the atlantis output files? Consider filling with shiny app in future
  source(config)
  # needs these files, for example config file CC3config.R is:
  
  # d.name <- here::here("atlantisoutput","CC_2063_OA_OFF_22")
  # functional.groups.file <- "CalCurrentV3Groups.csv"
  # biomass.pools.file <- "DIVCalCurrentV3_Biol.nc"
  # biol.prm.file <- "CalCurrentV3_Biol.prm"
  # box.file <- "CalCurrentV3_utm.bgm"
  # initial.conditions.file <- "DIVCalCurrentV3_Biol.nc"
  # run.prm.file <- "CalCurrentV3_run.xml"
  # scenario.name <- "CCV3"
  # bioind.file <- "outputCCV3BiomIndx.txt"
  # catch.file <- "outputCCV3Catch.txt"

  #Load functional groups
  funct.groups <- atlantisom::load_fgs(dir=d.name,
                           file_fgs = functional.groups.file)
  #Get just the names of active functional groups
  funct.group.names <- funct.groups %>% 
    filter(IsTurnedOn == 1) %>%
    select(Name) %>%
    .$Name
  
  # load true total biomass in tons
  truetotbio <- atlantisom::load_bioind(d.name, file_bioind = bioind.file, fgs = funct.groups)
  
  # load true catch in tons
  truecatchbio <- atlantisom::load_catch(d.name, file_catch = catch.file, fgs = funct.groups)

  # load YOY
  YOY <- atlantisom::load_yoy(d.name, paste0("output", scenario.name, "YOY.txt"))
  
  # load biol_prm
  biol <- atlantisom::load_biolprm(d.name, biol.prm.file)
  
  # load run_prm
  runpar <- atlantisom::load_runprm(d.name, run.prm.file)
  
  # load box info file
  boxpars <- atlantisom::load_box(d.name, box.file)

  # default run_truth setup will save the file, so check for that first
  if(!file.exists(file.path(d.name, 
                            paste0("output", scenario.name, "run_truth.RData")))){
    #Store all loaded results into an R object
    truth <- atlantisom::run_truth(scenario = scenario.name,
                       dir = d.name,
                       file_fgs = functional.groups.file,
                       file_bgm = box.file,
                       select_groups = funct.group.names,
                       file_init = initial.conditions.file,
                       file_biolprm = biol.prm.file,
                       file_runprm = run.prm.file,
                       verbose = TRUE
    )
  } else {
    truth <- get(load(file.path(d.name,
                                paste0("output", scenario.name, "run_truth.RData"))))
  }
  
  omlist <-list("funct.groups" = funct.groups, 
                "funct.group.names" = funct.group.names,
                "truetotbio" = truetotbio,
                "truecatchbio" = truecatchbio,
                "YOY" = YOY,
                "biol" = biol,
                "runpar" = runpar,
                "boxpars" = boxpars,
                "truth" = truth)
  
  return(omlist)
}
  

```

Usage: 

```{r exinit}

library(here)
CC3om <- om_init(here("config/CC3config.r"))

```

### Get assessment input data

Split to single species or subset of assessed species, get index data, get compositional data. By default, remove full om results and keep only species subsets to save memory.

#### Split to focal species

Is this where we should reconcile timesteps? depends what functions are expecting.

```{r inputs}

om_species <- function(species = spp, omlist, removefullom = TRUE){
  # spp format c("speciesname1", "speciesname2")
  if(!all(species %in% omlist$funct.group.names)) stop("species name not found") 
  species_ss <- species
  
  #subset species true bio
  truetotbio_ss <- omlist$truetotbio[omlist$truetotbio$species %in% species_ss,]

  #subset species true catch
  truecatchbio_ss <- omlist$truecatchbio[omlist$truecatchbio$species %in% species_ss,]

  #subset species YOY
  # get code matching species name to split YOY file
  code_ss <- omlist$funct.groups$Code[which(omlist$funct.groups$Name %in% species_ss)]
  # cut to a single species in YOY file
  YOY_ss <- omlist$YOY %>%
    select(Time, paste0(code_ss, ".0"))
  # reformat to be like all the other objects
  
  # numbers at agecl at full resolution (all polygons and layers)
  truenums_ss <- omlist$truth$nums[omlist$truth$nums$species %in% species_ss,]
  
  # biomass at agecl at full resolution (all polygons and layers)
  truebio_ss <- omlist$truth$biomass_ages[omlist$truth$biomass_ages$species %in% species_ss,]
  
  # reserve nitrogen at agecl at full resolution
  trueresn_ss <- omlist$truth$resn[omlist$truth$resn$species %in% species_ss,]
  
  # structural nitrogen at agecl at full resolution
  truestructn_ss <- omlist$truth$structn[omlist$truth$structn$species %in% species_ss,]
  
  # catch in numbers at agecl at full resoluation (all polygons, no layer in output)
  truecatchnum_ss <- omlist$truth$catch[omlist$truth$catch$species %in% species_ss,]
  
  #subset species biol parameters? no, may miss some globals that aren't by species
  
  #subset species functional group info
  funct.groups_ss <- omlist$funct.groups[omlist$funct.groups$Code %in% code_ss,]
  
  #keep the runpar and also need boxes for survey selection
  
  omlist_ss <- list("species_ss" = species_ss,
                    "code_ss" = code_ss,
                    "truetotbio_ss" = truetotbio_ss,
                    "truecatchbio_ss" = truecatchbio_ss,
                    "YOY_ss" = YOY_ss,
                    "truenums_ss" = truenums_ss,
                    "truebio_ss" = truebio_ss,
                    "trueresn_ss" = trueresn_ss,
                    "truestructn_ss" = truestructn_ss,
                    "truecatchnum_ss" = truecatchnum_ss,
                    "funct.group_ss" = funct.groups_ss,
                    "biol" = omlist$biol,
                    "boxpars" = omlist$boxpars,
                    "runpar" = omlist$runpar)
  
  if(removefullom) rm(omlist) #not removing passed data object
  
  return(omlist_ss)
}

```

Usage: 

```{r exsp}

CC3om_sardine <- om_species(c("Pacific_sardine"), CC3om)

```

#### Generate index data for assessment

```{r surveyconfig}

surveyconfig <- function(omlist_ss, usersurvey = usersurvey_file){
  #configure the independent survey, a default census is in config/survcensus.R
  #survey configuration must specify survey time, area, efficiency (q), selectivity
  #survey species inherited from omlist_ss
  survspp <- omlist_ss$species_ss
  # survey season and other time dimensioning parameters
  # generalized timesteps all models
  noutsteps <- omlist_ss$runpar$tstop/omlist_ss$runpar$outputstep
  timeall <- c(0:noutsteps)
  stepperyr <- if(omlist_ss$runpar$outputstepunit=="days") 365/omlist_ss$runpar$toutinc
  midptyr <- round(median(seq(0,stepperyr)))
  
  # model areas, subset in surveyconfig
  allboxes <- c(0:(omlist_ss$boxpars$nbox - 1))
  
  # fishery output: learned the hard way this can be different from ecosystem outputs
  fstepperyr <- if(omlist_ss$runpar$outputstepunit=="days") 365/omlist_ss$runpar$toutfinc
  
  # survey selectivity (agecl based)
  # should return all age classes fully sampled (Atlantis output is 10 age groups per spp)
  n_age_classes <- omlist_ss$funct.group_ss$NumCohorts
  age_classes <- 1:n_age_classes
  
  n_annages <- n_age_classes * omlist_ss$funct.group_ss$NumAgeClassSize
  annages <- 1:n_annages
  
  # user options for survey--default is a census with mid-year sample
  source(usersurvey, local = TRUE)
  
  surveyspecs <- list("survtime" = survtime,
                      "survboxes" = survboxes,
                      "surveffic" = surveffic,
                      "survselex" = survselex,
                      "surveffN" = surveffN,
                      "surv_cv" = surv_cv)
  
  return(surveyspecs)
}
```

Usage: 

```{r specsex}

mysurvey <- surveyconfig(CC3om_sardine, here("config/usersurvey.R"))
```


```{r omindices}

om_index <- function(usersurvey = usersurvey_file, 
                     userfishery = userfishery_file, 
                     omlist_ss, 
                     n_reps = n_reps,
                     save = TRUE){
  
  surveyspec <- surveyconfig(omlist_ss, usersurvey = usersurvey_file)
  
  #biomass based fishery independent survey index
  # this uses result$biomass_ages to sample biomass directly, no need for wt@age est
  survey_B <- atlantisom::create_survey(dat = omlist_ss$truebio_ss,
                                        time = surveyspec$survtime,
                                        species = surveyspec$survspp,
                                        boxes = surveyspec$survboxes,
                                        effic = surveyspec$surveffic,
                                        selex = surveyspec$survselex)
  
  # call sample_survey_biomass with a bunch of 1000s for weight at age
  # in the code it multiplies atoutput by wtatage/1000 so this allows us to use
  # biomass directly
  wtage <- data.frame(species=rep(survspp, each=max(age_classes)),
                      agecl=rep(c(1:max(age_classes)),length(survspp)),
                      wtAtAge=rep(1000.0,length(survspp)*max(age_classes)))
  
  # this is the step to repeat n_reps time if we want different realizations 
  # of the same survey design specified above; only observation error differs
  # using the census cv of 0 will produce identical reps!
  survObsBiomB <- list()
  for(i in 1:n_reps){
    survObsBiomB[[i]] <- atlantisom::sample_survey_biomass(survey_B, surv_cv, wtage)
  }
  
  #save survey indices, takes a long time to generate with lots of reps/species
  if(save){
    saveRDS(survObsBiomB, file.path(d.name, paste0(scenario.name, "surveyB.rds")))
  }
  
  #configure the fishery, a default is in config/fisherycensus.R
  #fishery configuration must specify survey time, area, efficiency (q), selectivity
  #fishery species inherited from omlist_ss
  source(fisheryconfig)
  
  #we are not currently subsetting fishery catch because we cannot correct catch.nc
  #  instead the catch in biomass from catch.txt is read in for the index
  #  we do not apply any cv to this, but we could this way (default cv=0)
  
  fishObsCatchB <- list()
  for(i in 1:n_reps){
    fishObsCatchB[[i]] <- atlantisom::sample_fishery_totcatch(omlist_ss$truecatchbio_ss, fish_cv)
  }

  if(save){
    saveRDS(fishObsCatchB, file.path(d.name, paste0(scenario.name, "fishCatch.rds")))
  }
 
  indices <- list("survObsBiomB" = survObsBiomB,
                  "fishObsCatchB" = fishObsCatchB)
  
  return(indices)
}

```

Usage: 

```{r exindex}

CC3om_sard_ind <- om_index(surveyconfig = here("config/survcensus.R"), 
                           fisheryconfig = here("config/fisherycensus.R"),
                           omlist_ss = CC3om_sardine, 
                           n_reps = 5, 
                           save = FALSE)

```

#### Generate compositional data for assessment

```{r omcomps}

```



